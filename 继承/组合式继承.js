let Parent = function(age) {
  this.name = 'Siri';
  this.hobby = [];
  this.age = age;
}
Parent.prototype.sayHi = function() {
  console.log('Hi ' + this.name);
}

let Child = function() {
  // 属性通过构造函数继承;
  Parent.call(this, 18);
  this.action = 'eat';
}
// 共享方法通过原型链继承;
Child.prototype = new Parent();



// 原型链继承特点: 共享父类属性和方法; 构造函数继承特点: 各子类实例有独立的属性和方法;
// 我们期望各子类实例能共享父类的方法, 同时能维护自己的属性;
// 组合式继承: 在父类原型上定义方法, 在父类构造函数内定义属性, 子类通过原型链继承实现对函数的复用，通过构造函数继承保证每个实例都有它自己的属性;
// 1. 子类实例能维护自己的属性, 同时共享父类方法;
// 2. 组合式继承最大的缺点在于其调用两次父构造函数, 一次是设置子类实例的原型的时候, 一次是在创建子类型实例的时候; 这导致实例对象和原型对象上的父类属性值重复, 子类索引父类属性时，会优先在实例对象上找到属性, 不会继续通过原型链向原型对象查找，而这部分原型对象上的属性值就浪费了存储空间;
// 组合式继承的缺点在后续寄生式组合继承中解决;